# 命令模式

GoF 中的定义：

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

> 命令模式是一种回调的面向对象实现。

简而言之，便是将 “操作” 封装为类，将其实例化为对象后作为 “第一公民” 对待，一个通俗易懂的应用便是如绘图软件中的 `Ctrl+Z` 撤销功能

## 角色按键控制

以手柄为例，四个按键 `X Y B A` 分别对应角色的 `Jump FireGun Lurch SwapWeapon` 四个行为，如下图所示：

![命令模式_1.png](./img/命令模式_1.png)

那么，可以轻松想到的代码便是下面这种：

```c++
class InputHandler
{
public:
    void handleInput();
};

void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) jump();
    else if (isPressed(BUTTON_Y)) fireGun();
    else if (isPressed(BUTTON_A)) swapWeapon();
    else if (isPressed(BUTTON_B)) lurchIneffectively();
}
```

虽然这样的代码可以完成功能，但是由于按键响应是硬编码的，所以无法做到根据玩家的习惯或意愿在游戏的 “设置” 中修改按键键位，那么，最简单的命令模式便出现了，我们首先定义一个用来描述 “命令” 的基类，来代表可触发的游戏行为：

```c++
class Command
{
public:
    virtual ~Command() {}
    virtual void execute() = 0;
};
```

然后将刚才直接调用的指令函数封装到类中，便是下面这种代码：

```c++
class JumpCommand : public Command
{
public:
    virtual void execute() { jump(); }
};

class FireCommand : public Command
{
public:
    virtual void execute() { fireGun(); };
};

// 其余指令代码不再赘述
```

然后在刚刚剥离出去的 `InputHandler` 输入处理类中，只需要为每个按键存储一个指向指令的指针：

```c++
class InputHandler
{
public:
    void handleInput();

private:
    Command* buttonX_;
    Command* buttonY_;
    Command* buttonA_;
    Command* buttonB_;
};

void InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) buttonX_->execute();
    else if (isPressed(BUTTON_Y)) buttonY_->execute();
    else if (isPressed(BUTTON_A)) buttonA_->execute();
    else if (isPressed(BUTTON_B)) buttonB_->execute();
}
```

现在，在每次按键后，会通过一层间接寻址调用函数，示意图如下：

![命令模式_2.png](./img/命令模式_2.png)

注意，这里的代码并没有对 `NULL` 进行单独检测，而在实际的游戏开发过程中，可能并不是每一个手柄上或键盘上的按键都对应着一个命令，这时我们便可以定义一个单独的空命令类继承自命令基类，而它的执行函数不坐任何事情，这样就可以不需要为每一个键设置为 `NULL`，而只需要指向这个类，如下方的代码：

```c++
class EmptyCommand : public Command
{
public:
    virtual void execute() {};
}
```

这种使用方式同样为一种设计模式，它的名字便是 “空对象模式”

## 解耦角色和命令

在上述内容中，我们做了一个十分有局限性的假设，那就是像 `jump() fireGun()` 等函数可以找到玩家角色，获取并修改玩家数据，就像操控木偶一样操控玩家对象，这样不仅对代码有了更多限制，而且如果想要让玩家控制不同的游戏角色，这也是无法轻易实现的。

如果我们把玩家所控制的角色变为指令执行时的参数传入，而不是让函数去寻找它们控制的角色那么上述两个问题便都可以轻而易举地解决：

```c++
class Command
{
public:
    virtual ~Command() {}
    virtual void execute(GameActor& actor) = 0;
};

class JumpCommand : public Command
{
public:
    virtual void execute(GameActor& actor) { actor.jump(); }
};

class FireCommand : public Command
{
public:
    virtual void execute(GameActor& actor) { actor.fireGun(); };
};

// 其余指令代码不再赘述
```

到目前为止我们只修改了 `Command` 类，在原先代码中真正调用 `execute()` 函数的 `InputHandler` 类同样需要修改。

我们在这里使用 “延迟调用”，不将玩家作为参数传入后在 `handleInput()` 函数中自动调用，而是将它延迟到外部手动调用，这样它在调用时才会知晓自己作用在哪个角色上：

```c++
class InputHandler
{
public:
    Command* handleInput();     // 只需要修改此处函数

private:
    Command* buttonX_;
    Command* buttonY_;
    Command* buttonA_;
    Command* buttonB_;
};

Command* InputHandler::handleInput()
{
    if (isPressed(BUTTON_X)) return buttonX_;
    else if (isPressed(BUTTON_Y)) return buttonY_;
    else if (isPressed(BUTTON_A)) return buttonA_;
    else if (isPressed(BUTTON_B)) return buttonB_;
}
```

我们在实际调用时只需要这样写：

```c++
GameActor actor;
InputHandler inputHandler;
Command* command = inputHandler.handleInput();
if (command) command->execute(actor);
```

有了这样的代码，我们便可以让玩家轻松控制不同的角色而不需要为每个角色单独编写按键响应代码；同样，如果我们想让AI托管玩家或为游戏中新增和玩家行为相似的AI，只需要让AI生成 `Command` 对象便可以做到

如果我们把这些指令序列化，并且通过网络传输到另一台机器上，并且反序列化重现出来，这样我们就可以实现网络多人游戏的基础部分了

## 撤销和重做

这个例子可能是命令模式最广为人知的使用场景了

如果一个命令对象可以做一件事，那么它也一定可以撤销这件事——这在策略类游戏中很常见（如悔棋等），或者在各类编辑器中，回滚使用者的操作（如PS或各类文本编辑器）