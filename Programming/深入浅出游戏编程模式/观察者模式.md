# 观察者模式

观察者模式可能是应用最为广泛的设计模式了，Java 将它放到了自己的核心库 `java.util.Observer` 中，C# 更是将其通过 `event` 关键字把它嵌入到了自己的语法中

一种常见的定义可以把它描述为：

> 一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统

在游戏中最常见的用途便是 “成就系统”

## 成就系统

在游戏中，成就系统存储了玩家完成的各种各样的挑战，譬如 “通过穿模让自己从桥面上掉下去”（虽然一般来说，严谨的游戏开发者都不会在游戏的最终发布版本中设计此类成就），也就是说，在处理 “从桥上掉落” 这个物理引擎相关的代码部分，必须要对诸如 `unlockFallOffBridge()` 的方法进行调用，那么，成就系统便和物理系统紧密地耦合到了一起，而诸如 “在当前关卡回档 1000 次” 这类成就，可能又会和存档系统进行交互，代码又会交织成一团乱麻……

那么，我们该如何解耦成就系统和其他它所关心的系统之间的关系呢？

观察者模式就是处理这类棘手问题的专家！

例如，一个常见的物理系统可能会处理重力，追踪哪些游戏对象待在地表，哪些坠入深渊，为了实现上述的桥面掉落成就，我们可以这样做：

```c++
void Physics::updateEntity(Entity& entity)
{
    bool wasOnSurface = entity.isOnSurface();
    entity.accelerate(GRAVITY);
    entity.update();
    if (wasOnSurface && !entity.isOnSurface())
        // 如果更新之前位于桥面而更新后不在桥面上，则将 “开始坠落” 事件广播出去
        notify(entity, EVENT_START_FALL);
}
```

这段代码所做的事情就仿佛在说，“额，我不知道谁对这件事感兴趣，但是刚才那个东西掉下去了，你们可以做自己想做的事情”

物理引擎虽然确实决定了要发送什么通知，但是这并没有完全解耦：成就系统需要检查这个正在下落的游戏对象时主角还是主角射出的弓箭，还需要检查在这之前主角有没有过类似的经历（毕竟没有人希望自己在每次掉下桥时都能收到礼花和炫光相伴的成就解锁），这些代码都无需牵扯物理引擎

仔细思考一下，`notify()` 函数的具体实现似乎是一个到现在为止还没有解决的麻烦，如果我们更新了成就系统，或者坠落下桥的成就系统不再关心这件事，那么我们就可能需要动态那些正在关心的听众们的列表，所以这里就对灵活性提出了更高的要求

## 如何实现？

Talk is cheap，如果我们还不知道如何设计消息的发布者，那么就先从那些收听者们这里进行编码：

```c++
class Observer
{
public:
    virtual ~Observer() {}
    virtual void onNotify(const Entity& entity, Event event) = 0;
};
```

`onNotify()` 函数所需要的参数取决于具体的设计，典型的参数便是代码中所描述的：发送通知的对象和一个装入其他数据细节的参数；泛型或模板编程在这里可能十分有用，在这里为了方便起见，参数被硬编码为一个游戏实体和一个描述发生了什么事件的枚举

然后，成就系统我们就可以通过继承观察者类来实现：

```c++
class Achievements : public Observer
{
public:
    virtual void onNotify(const Entity& entity, Event event)
    {
        switch (event)
        {
        case EVENT_ENTITY_FALL:
            if (entity.isHero() && heroIsOnBridge_)
                unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);    // 解锁成就
            break;

            // 处理其他事件的代码，更新 heroIsOnBridge_ 变量……
        }
    }

private:
    void unlock(Achievement achievement)
    {
        // 判断成就是否已经解锁并尝试解锁成就
    }

    bool heroIsOnBridge_;
};
```

被观察的对象拥有通知的方法函数，在 GoF 中，这些对象被称为 “主题”，主题会有一个列表，用来存储等它通知的观察者：

```c++
class Subject
{
private:
    Observer* observers_[MAX_OBSERVERS];
    int numObservers_;
};
```

在实际开发中，这里的 `observer_` 使用动态集合效果会更好（接下来的代码会说明这点），这里使用定长数组方便不习惯 C++ 标准库的读者们理解

关键在于主题暴露了公开的 API 来修改这个列表：

```c++
class Subject
{
public:
    void addObserver(Observer* observer)
    {
        // 将新的观察者添加到数组中……
    }

    void removeObserver(Observer* observer)
    {
        // 将观察者从数组中移除
    }

    // 其他代码……
};
```

到现在为止，这就允许了外界代码控制谁接收通知，被观察者通过主题与观察者交流，但是不相互耦合，在这个示例中，没有一行物理代码会提及成就，但是二者仍可以相互交流，这就是观察者模式的精髓之处

被观察者使用列表而不是单一变量的设计也是十分重要的，这就允许了多个观察者（可能涉及多个系统）同时对于一个目标主题做出反应，譬如音效系统可能也需要在玩家坠落桥底的时候播放合适的音乐，而单一变量则会将后面添加的观察者顶替先前观察者的位置

现在，被观察者（主题）的剩余任务就是发送通知了：

```c++
class Subject
{
protected:
    void notify(const Entity& entity, Event event)
    {
        for (int i = 0; i < numObservers_; i++)
            observers_[i]->onNotify(entity, event);
    }
};
```

注意，上面的示例假设了观察者不会在自己的 `onNotify()` 方法中修改观察者列表和观察者对象，如果观察者希望能够在收到通知时修改游戏对象的数据，那么开发者可能需要关注当前观察者列表中存在的观察者会不会对通知的顺序敏感，有时不同的通知顺序在同一个实体被修改时会产生不同的结果，毕竟看似同时通知的设计具体是通过数组的遍历先后通知实现的

回到物理系统上，我们只需要给物理系统添加挂钩让它可以发送消息，成就系统便可以和这一部分连线来接收消息，按照传统的设计模式方法实现，通过继承：

```c++
class Physics : public Subject
{
public:
    void updateEntity(Entity& entity);
};
```

注意，在先前的代码里面，我们将 `notify()` 实现为了 `Subject` 内的保护方法，这样派生的物理系统便可以调用并发出通知，但是外部代码不可以；同时，`addObserver()` 和 `removeObserver()` 是公开的，所以任何能够接触物理引擎的东西都可以观察它

在实际开发过程中，我们会避免在这里使用继承，让 `Physics` 拥有一个 `Subject` 实例，而不是直接观察物理系统本身，例如被观察的是独立的 “下落事件” 的对象，观察者可以这样注册自己：

```c++
physics.entityFell().addObserver(this);
```

关于 “观察者” 系统和 “事件” 系统的不同之处，Bob Nystrom 在《Game Programming Patterns》 中写道：

> 对我而言，这是 “观察者” 与 “事件” 系统的不同之处。使用前者，你观察做了有趣事情的事物。使用后者，你观察的对象代表了发生的有趣事情

现在，当物理系统做了值得被关注的事情，它便会调用 `notify()`，就像前面代码所展示的，它遍历了观察者列表，通知了所有观察者

![观察者模式_1.png](./img/观察者模式_1.png)

简单来说，只需要一个类管理一个列表指向接口实例的指针

> 很简单，对吧？难以置信的是，如此直观的东西是无数程序和应用框架交流的主心骨

## 观察者模式的缺陷？

