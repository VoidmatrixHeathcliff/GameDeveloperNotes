# 观察者模式

观察者模式可能是应用最为广泛的设计模式了，Java 将它放到了自己的核心库 `java.util.Observer` 中，C# 更是将其通过 `event` 关键字把它嵌入到了自己的语法中

一种常见的定义可以把它描述为：

> 一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统

在游戏中最常见的用途便是 “成就系统”

## 成就系统

在游戏中，成就系统存储了玩家完成的各种各样的挑战，譬如 “通过穿模让自己从桥面上掉下去”（虽然一般来说，严谨的游戏开发者都不会在游戏的最终发布版本中设计此类成就），也就是说，在处理 “从桥上掉落” 这个物理引擎相关的代码部分，必须要对诸如 `unlockFallOffBridge()` 的方法进行调用，那么，成就系统便和物理系统紧密地耦合到了一起，而诸如 “在当前关卡回档 1000 次” 这类成就，可能又会和存档系统进行交互，代码又会交织成一团乱麻……

那么，我们该如何解耦成就系统和其他它所关心的系统之间的关系呢？

观察者模式就是处理这类棘手问题的专家！

例如，一个常见的物理系统可能会处理重力，追踪哪些游戏对象待在地表，哪些坠入深渊，为了实现上述的桥面掉落成就，我们可以这样做：

```c++
void Physics::updateEntity(Entity& entity)
{
    bool wasOnSurface = entity.isOnSurface();
    entity.accelerate(GRAVITY);
    entity.update();
    if (wasOnSurface && !entity.isOnSurface())
        // 如果更新之前位于桥面而更新后不在桥面上，则将 “开始坠落” 事件广播出去
        notify(entity, EVENT_START_FALL);
}
```

这段代码所做的事情就仿佛在说，“额，我不知道谁对这件事感兴趣，但是刚才那个东西掉下去了，你们可以做自己想做的事情”

物理引擎虽然确实决定了要发送什么通知，但是这并没有完全解耦：成就系统需要检查这个正在下落的游戏对象时主角还是主角射出的弓箭，还需要检查在这之前主角有没有过类似的经历（毕竟没有人希望自己在每次掉下桥时都能收到礼花和炫光相伴的成就解锁），这些代码都无需牵扯物理引擎

仔细思考一下，`notify()` 函数的具体实现似乎是一个到现在为止还没有解决的麻烦，如果我们更新了成就系统，或者坠落下桥的成就系统不再关心这件事，那么我们就可能需要动态那些正在关心的听众们的列表，所以这里就对灵活性提出了更高的要求

## 如何实现？

Talk is cheap，如果我们还不知道如何设计消息的发布者，那么就先从那些收听者们这里进行编码：

```c++
class Observer
{
public:
    virtual ~Observer() {}
    virtual void onNotify(const Entity& entity, Event event) = 0;
};
```

`onNotify()` 函数所需要的参数取决于具体的设计，典型的参数便是代码中所描述的：发送通知的对象和一个装入其他数据细节的参数；泛型或模板编程在这里可能十分有用，在这里为了方便起见，参数被硬编码为一个游戏实体和一个描述发生了什么事件的枚举

然后，成就系统我们就可以通过继承观察者类来实现：

```c++
class Achievements : public Observer
{
public:
    virtual void onNotify(const Entity& entity, Event event)
    {
        switch (event)
        {
        case EVENT_ENTITY_FALL:
            if (entity.isHero() && heroIsOnBridge_)
                unlock(ACHIEVEMENT_FELL_OFF_BRIDGE);    // 解锁成就
            break;

            // 处理其他事件的代码，更新 heroIsOnBridge_ 变量……
        }
    }

private:
    void unlock(Achievement achievement)
    {
        // 判断成就是否已经解锁并尝试解锁成就
    }

    bool heroIsOnBridge_;
};
```